Всем привет, начинаем четвёртый выпуск первого сезона.
В прошлом эпизоде я рассказал о троичных мультиплексорах, ну а в этом мы построим первое вменяемое устройство, а именно ячейку памяти, которая будет хранить один трит информации.
Это звучит сложнее, нежели в реальности делается.
Напоминаю, что на одной плате тримукса у нас размещено два мультиплексора.
Поэтому, если я воткну один тримукс в эту макетку, то я получу следующую схему.

Это статическая ячейка памяти с запоминанием по уровню. У неё четыре вывода: A,B,C и Q.
Линии направленные, A,B и C работают на вход, ну а линия Q на выход.

Обратите внимание, что нижний мультиплексор подключен просто в режиме прозрачного буфера: на выходе Q сигнал повторяет сигнал на селекторе.
Этот буфер сделан для поддержания уровня напряжения в схеме во время запоминания информации.
Основная же работа по управлению ложится на плечи верхнего мультиплексора.
Смотрите, если на вход C подать минус единицу, то выход Q будет повторять сигнал с линии A.
Если же на вход C подать единицу, то выход Q будет повторять сигнал с линии B, игнорируя при этом линию A.
А что будет, если на вход C подать логический ноль?
А тогда получится, что внутри нашей схемы сигнал с выхода Q закольцовывается, таким образом запоминая ту информацию, которая была в памяти ровно перед тем моментом, 
когда селектор C переключился в ноль.
Теперь я могу изменять линии записи A и B как хочу, это никак не влияет на то, что записано в нашу ячейку памяти.
Например, если я хочу запомнить 1, то я ставлю A в 1, C в -1, и потом в 0. И теперь у нас запомнена 1.
Кстати, именно для этого закольцовывания нам пришлось поставить нижний мультиплексор в режиме повторителя сигнала, иначе он бы очень быстро затух.

Мы сумели сделать ячейку памяти, используя исключительно мультиплексоры, и ничего больше. Здорово, правда?
Точно такая же ситуация будет и с сумматорами, счётчиками и всем остальным, что необходимо для постройки полноценного вычислителя.

Продолжаем разговор. Эта ячейка памяти прекрасно запоминает информацию в зависимости от уровня сигнала C, но мне будет удобнее, если сигналом к запоминанию будет 
не сам уровень, но его изменение. То есть, я хочу, чтобы моя память сохраняла информацию по фронту сигнала на линии клока.
Не беда, это совсем нетрудно сделать.

Мы можем позаимствовать много идей из двоичного мира. Там ровно эта задача уже решена.
Если взять две одинаковые двоичные защёлки, то собрав их в каскад, можно получить D-флип-флоп.
Ну а я что, рыжий? Давайте сделаем ровно так же, собрав две одинаковые ячейки во флип-флап-флоп!

Итак, давайте тестировать, вот я собрал флип-флап-флоп, она же ячейка памяти с запоминанием по фронту сигнала.
Розовые провода это те, что нужны для каждой защёлки по отдельности, ну а остальные - это то, что нужно для того, чтобы
собрать две защёлки во флип-флап-флоп.
На плату ввода-вывода я вывел три внешние линии нашей схемы: тактирующий сигнал, линия записи и линия памяти, она же выход ведомой защёлки.
Я буду тактировать свой вычислитель троичной пилой; эта ячейка запоминает входящий сигнал по двум ниспадающим фронтам P-O и O-N.

Давайте скажем, что я хочу записать в память логическую единицу.
Я подаю на линию A +5 вольт, и как только клок перейдёт из состояния P в состояние N, запись окончена.
Теперь я могу изменять состояние A сколько угодно, это не отражается на линии Q.
Давайте запишем минус единицу.
Я подаю -5 вольт на линию A, когда клок переходит в единицу, выход ведущей защёлки получает значение из линии записи.
Но как только клок переходит в ноль, то ведущая защёлка уже запомнила значение, и линия записи теперь игнорируется.
И при дальнейшем движении клока произойдёт копирование информации из ведущей в ведомую защёлку.

Ну что ж, с полевыми экспериментами покончено, давайте рассмотрим настоящий кусок моего вычислителя.
Вот эта плата несёт на себе три флип-флап-флопа: 1,2,3. То есть, она может запомнить число от -13 до +13.
Давайте посмотрим на неё снизу.
Как можно видеть, она несёт на себе лишь конденсаторы питания и токоограничительные резисторы.
Вот этот операционный усилитель в вычислениях не участвует, он здесь исключительно в качестве драйвера для светодиодов, которые отражают состояние памяти,
чтобы не создавать лишней нагрузки на линии вывода нашей памяти.

Подключается этот модуль при помощи стандартного десятипинового шлейфа: три пина на питание, один на клок, и ещё три пары пинов записи и чтения памяти для трёх тритов.
Давайте его подключим!

Ну вот, готово. Как я и говорил, этот модуль имеет семь управляющих линий: тактирующий сигнал, трёхтритное число на запись и трёхтритное число на чтение из памяти.
В принципе, состояние памяти также отображается светодиодами на самом модуле, так что вот эти светодиоды и вот эти будут отображать одно и то же число.
Сейчас в памяти записан ноль, смотрите, все три светодиода погашены.
Давайте запишем в память, скажем, 8.
8 это 9-1, как только тактирующий сигнал перейдёт из состояния P в состояние N, запись окончена.
Смотрите, 9+0-1 = 8.
Теперь любое изменение на линиях записи не влияет на то, что записано в память.
Давайте попробуем ещё раз. Итого 11.
Давайте теперь с обратным знаком!
-11 это -9-3+1. Ещё раз: запись идёт по двум ниспадающим фронтам. Один, два.
Смотрите, модуль памяти прекрасно работает.

На этом я завершаю четвёртый выпуск первого сезона моего микросериала о ненормальном программировании.
В следующий раз мы поговорим о полной плате памяти моего вычислителя, которая несёт на себе тринадцать таких модулей, а также схему адресации.
До новых встреч в эфире!

